{"version":3,"file":"defineElementComponent.js","sources":["../../src/lib/elements/defineElementComponent.tsx"],"sourcesContent":["import {AssignableType, Type} from \"@co.mmons/js-utils/core\";\nimport type {JSX, ParentProps} from \"solid-js\";\nimport {children, Component, createMemo, createRenderEffect, mergeProps, sharedConfig, splitProps} from \"solid-js\";\nimport {getNextElement, spread} from \"solid-js/web\";\nimport {CustomElement} from \"./CustomElement\";\nimport {CustomElementJSXAttributes} from \"./CustomElementJSXAttributes\";\nimport {CustomElementJSXEvents} from \"./CustomElementJSXEvents\";\nimport {CustomElementProps} from \"./CustomElementProps\";\nimport {CustomElementReactiveProp} from \"./CustomElementReactiveProp\";\nimport {registerElement} from \"./registerElement\";\n\ntype DefineElementFn = () => void;\n\nexport type CustomElementComponent<TagName extends string, ElementType extends CustomElement, ComponentProps = CustomElementProps<ElementType>> = Component<ComponentProps & CustomElementJSXAttributes> & {\n    tagName: TagName;\n    register(): void\n}\n\nexport type ElementComponent<TagName extends string, Props, ComponentElement extends HTMLElement> = Component<Partial<Props> & JSX.HTMLAttributes<ComponentElement>> & {tagName: TagName, register: () => void};\n\ntype PropsHandler<P extends {[key: string]: any}> = (props: P) => P;\n\nexport interface ElementComponentOptions {\n    define?: DefineElementFn | DefineElementFn[];\n    initialProps?: {[key: string]: any};\n    propsHandler?: (props: {[key: string]: any}) => void;\n}\n\nexport function defineElementComponent<TagName extends string, ElementType extends CustomElement, Props = CustomElementProps<ElementType>, Events extends {[P in keyof Events]: Event} = any>(tagName: TagName, elementType: AssignableType<ElementType>, props?: Props, events?: Events): CustomElementComponent<TagName, ElementType, Props & CustomElementJSXEvents<ElementType, Events> & Omit<JSX.HTMLAttributes<ElementType>, keyof CustomElementJSXEvents<ElementType, Events>>>;\n\nexport function defineElementComponent<TagName extends string, ComponentElement extends HTMLElement, Props>(tagName: TagName, childrenAllowed: true, options?: ElementComponentOptions): ElementComponent<TagName, Props & ParentProps, ComponentElement>;\n\nexport function defineElementComponent<TagName extends string, ComponentElement extends HTMLElement, Props>(tagName: TagName, childrenAllowed: false, options?: ElementComponentOptions): ElementComponent<TagName, Props, ComponentElement>;\n\nexport function defineElementComponent(tagName: string, elementTypeOrChildrenAllowed: AssignableType | boolean, options?: ElementComponentOptions | any, events?: any): any {\n\n    const solidElementType = typeof elementTypeOrChildrenAllowed !== \"boolean\" && elementTypeOrChildrenAllowed as AssignableType;\n\n    function register() {\n\n        if (customElements.get(tagName)) {\n            return;\n\n        } else if (solidElementType) {\n            registerElement(tagName, solidElementType);\n\n        } else if (options?.define) {\n            for (const d of Array.isArray(options.define) ? options.define : [options.define]) {\n                d();\n            }\n        }\n    }\n\n    let cmp: any;\n\n    if (solidElementType) {\n\n        const extendedType: Type & {reactive: {[propName: string]: boolean | CustomElementReactiveProp}} = solidElementType as any;\n\n        cmp = (rawProps: ParentProps<any>) => {\n            register();\n\n            const rawChildren = children(() => rawProps.children);\n            const [, props] = splitProps(rawProps, [\"children\"]);\n\n            createRenderEffect(() => {\n                const descriptors = Object.getOwnPropertyDescriptors(props);\n                for (const key of Object.keys(descriptors)) {\n                    const fixed = extendedType.reactive[key] ? `prop:${key}` : fixPropName(key);\n                    if (key !== fixed) {\n                        Object.defineProperty(props, fixed, descriptors[key]);\n                        delete props[key as any];\n                    }\n                }\n            })\n\n            return createMemo(() => {\n                const el: any = sharedConfig.context ? getNextElement() : document.createElement(tagName);\n                const noShadow = (el as any)[\"renderRoot\"] === el;\n                const childrenProp = noShadow ? \"prop:slottedChildren\" : \"children\";\n\n                spread(el, mergeProps(props, {[childrenProp]: rawChildren}), false, false);\n\n                // createEffect(() => {\n                //     for (const propName of Object.keys(props)) {\n                //         const niu = props[propName];\n                //         const prev = el[propName];\n                //         if (niu !== prev) {\n                //             el[propName] = niu;\n                //         }\n                //     }\n                // })\n                //\n                // spread(el, mergeProps(others, {\n                //     children: (!noShadow && rawChildren) ?? [],\n                //     \"slotted-children\": (noShadow && rawChildren.toArray()) ?? []\n                // }), false, noShadow);\n\n                return el;\n            })\n        }\n\n    } else {\n\n        cmp = ((rawProps: any) => {\n\n            register();\n\n            return createMemo(() => {\n\n                const rawChildren = children(() => rawProps.children);\n                const [_, others] = splitProps(rawProps, [\"children\"]);\n\n                const el = sharedConfig.context ? getNextElement() : document.createElement(tagName);\n\n                createRenderEffect(() => {\n                    options?.propsHandler?.(others);\n\n                    const descriptors = Object.getOwnPropertyDescriptors(others);\n                    for (const key of Object.keys(descriptors)) {\n                        const fixed = fixPropName(key);\n                        if (fixed !== key) {\n                            Object.defineProperty(others, fixed, descriptors[key]);\n                            delete others[key];\n                        }\n                    }\n                })\n\n                spread(el, mergeProps(options?.initialProps, others, {children: (elementTypeOrChildrenAllowed && rawChildren) ?? []}), false, !elementTypeOrChildrenAllowed);\n\n                return el;\n            })\n        })\n    }\n\n    cmp[\"tagName\"] = tagName;\n    cmp[\"register\"] = register;\n\n    return cmp;\n}\n\nconst notFixableProps = [\"class\", \"className\", \"classList\", \"ref\", \"style\"];\n\nfunction fixPropName(key: string) {\n\n    if (key.includes(\":\") || key.startsWith(\"on\") || notFixableProps.includes(key)) {\n        return key;\n    } else if (key.includes(\"-\")) {\n        return `attr:${key}`;\n    } else {\n        return `prop:${key}`;\n    }\n\n    return key.replace(/\\.?([A-Z]+)/g, (x, y) => \"-\" + y.toLowerCase()).replace(\"_\", \"-\").replace(/^-/, \"\");\n}\n"],"names":["defineElementComponent","tagName","elementTypeOrChildrenAllowed","options","events","solidElementType","register","customElements","get","registerElement","define","d","Array","isArray","cmp","extendedType","rawProps","rawChildren","children","props","splitProps","createRenderEffect","descriptors","Object","getOwnPropertyDescriptors","key","keys","fixed","reactive","fixPropName","defineProperty","createMemo","el","sharedConfig","context","getNextElement","document","createElement","childrenProp","spread","mergeProps","_","others","propsHandler","initialProps","notFixableProps","includes","startsWith"],"mappings":";;;AAkCO,SAASA,EAAuBC,GAAiBC,GAAwDC,GAAyCC,GAAmB;AAExK,QAAMC,IAAmB,OAAOH,KAAiC,aAAaA;AAE9E,WAASI,IAAW;AAEhB,QAAIC,gBAAeC,IAAIP,CAAO;AAGvB,UAAII;AACPI,QAAAA,EAAgBR,GAASI,CAAgB;AAAA,eAElCF,KAAAA,QAAAA,EAASO;AAChB,mBAAWC,KAAKC,MAAMC,QAAQV,EAAQO,MAAM,IAAIP,EAAQO,SAAS,CAACP,EAAQO,MAAM;AAC5EC,UAAAA;;EAGZ;AAEA,MAAIG;AAEJ,MAAIT,GAAkB;AAElB,UAAMU,IAA6FV;AAEnGS,IAAAA,IAAOE,CAAAA,MAA+B;AAClCV,MAAAA;AAEA,YAAMW,IAAcC,EAAS,MAAMF,EAASE,QAAQ,GAC9C,CAAA,EAAGC,CAAK,IAAIC,EAAWJ,GAAU,CAAC,UAAU,CAAC;AAEnDK,aAAAA,EAAmB,MAAM;AACrB,cAAMC,IAAcC,OAAOC,0BAA0BL,CAAK;AAC1D,mBAAWM,KAAOF,OAAOG,KAAKJ,CAAW,GAAG;AACxC,gBAAMK,IAAQZ,EAAaa,SAASH,CAAG,IAAK,QAAOA,MAAQI,EAAYJ,CAAG;AAC1E,UAAIA,MAAQE,MACRJ,OAAOO,eAAeX,GAAOQ,GAAOL,EAAYG,CAAG,CAAC,GACpD,OAAON,EAAMM,CAAG;AAAA,QAExB;AAAA,MACJ,CAAC,GAEMM,EAAW,MAAM;AACpB,cAAMC,IAAUC,EAAaC,UAAUC,EAAgB,IAAGC,SAASC,cAAcpC,CAAO,GAElFqC,IADYN,EAAW,eAAkBA,IACf,yBAAyB;AAEzDO,eAAAA,EAAOP,GAAIQ,EAAWrB,GAAO;AAAA,UAAC,CAACmB,CAAY,GAAGrB;AAAAA,QAAW,CAAC,GAAG,IAAO,EAAK,GAiBlEe;AAAAA,MACX,CAAC;AAAA;EAGT;AAEIlB,IAAAA,IAAQE,CAAAA,OAEJV,KAEOyB,EAAW,MAAM;AAEpB,YAAMd,IAAcC,EAAS,MAAMF,EAASE,QAAQ,GAC9C,CAACuB,GAAGC,CAAM,IAAItB,EAAWJ,GAAU,CAAC,UAAU,CAAC,GAE/CgB,IAAKC,EAAaC,UAAUC,EAAgB,IAAGC,SAASC,cAAcpC,CAAO;AAEnFoB,aAAAA,EAAmB,MAAM;;AACrBlB,SAAAA,IAAAA,KAAAA,gBAAAA,EAASwC,iBAATxC,QAAAA,EAAAA,KAAAA,GAAwBuC;AAExB,cAAMpB,IAAcC,OAAOC,0BAA0BkB,CAAM;AAC3D,mBAAWjB,KAAOF,OAAOG,KAAKJ,CAAW,GAAG;AACxC,gBAAMK,IAAQE,EAAYJ,CAAG;AAC7B,UAAIE,MAAUF,MACVF,OAAOO,eAAeY,GAAQf,GAAOL,EAAYG,CAAG,CAAC,GACrD,OAAOiB,EAAOjB,CAAG;AAAA,QAEzB;AAAA,MACJ,CAAC,GAEDc,EAAOP,GAAIQ,EAAWrC,KAAAA,gBAAAA,EAASyC,cAAcF,GAAQ;AAAA,QAACxB,WAAWhB,KAAgCe,MAAgB,CAAA;AAAA,MAAE,CAAC,GAAG,IAAO,CAACf,CAA4B,GAEpJ8B;AAAAA,IACX,CAAC;AAITlB,SAAAA,EAAI,UAAab,GACjBa,EAAI,WAAcR,GAEXQ;AACX;AAEA,MAAM+B,IAAkB,CAAC,SAAS,aAAa,aAAa,OAAO,OAAO;AAE1E,SAAShB,EAAYJ,GAAa;AAE9B,SAAIA,EAAIqB,SAAS,GAAG,KAAKrB,EAAIsB,WAAW,IAAI,KAAKF,EAAgBC,SAASrB,CAAG,IAClEA,IACAA,EAAIqB,SAAS,GAAG,IACf,QAAOrB,MAEP,QAAOA;AAIvB;"}