{"version":3,"file":"registerElement.js","sources":["../../src/lib/elements/registerElement.tsx"],"sourcesContent":["import {AssignableType} from \"@co.mmons/js-utils/core\";\nimport {compose, ICustomElement, register} from \"component-register\";\nimport {getCurrentElement, withSolid} from \"solid-element\";\nimport {splitProps} from \"solid-js\";\nimport {CustomElement} from \"./CustomElement\";\n\nexport function registerElement<ElementType extends CustomElement>(tagName: string, elementConstructor: AssignableType<ElementType>) {\n\n    if (customElements.get(tagName)) {\n        return;\n    }\n\n    const extendedConstructor: {reactive: {[propName: string]: boolean}, __shadowStyles: string | string[]} = elementConstructor as any;\n\n    const propsDefinitions: {[propName: string]: {\n            value: undefined;\n            attribute: string;\n            notify: boolean;\n            reflect: boolean;\n            parse: boolean;\n        }} = {slottedChildren: {value: undefined, attribute: \"slotted-children\", notify: false, reflect: false, parse: false}};\n\n    for (const [propName, propValue] of Object.entries(extendedConstructor.reactive ?? {})) {\n        const propConfig = {value: undefined, notify: false, parse: false, reflect: false, attribute: undefined as any as string};\n\n        if (typeof propValue === \"object\") {\n            Object.assign(propConfig, propValue);\n        }\n\n        propsDefinitions[propName] = propConfig;\n    }\n\n    const connectedCallback = elementConstructor.prototype.connectedCallback;\n    const disconnectedCallback = elementConstructor.prototype.disconnectedCallback;\n\n    let renderRoot: PropertyDescriptor | undefined;\n\n    let parentClass = elementConstructor;\n    while (parentClass !== HTMLElement) {\n        renderRoot = Object.getOwnPropertyDescriptor(parentClass.prototype, \"renderRoot\");\n        if (renderRoot) {\n            break;\n        }\n        parentClass = Object.getPrototypeOf(parentClass);\n    }\n\n    const finalConstructor = compose(register(tagName, propsDefinitions, {BaseElement: elementConstructor}), withSolid)((rawProps) => {\n\n        const shadowStyles = extendedConstructor.__shadowStyles;\n        const [children, props] = splitProps(rawProps, [\"slottedChildren\"]);\n\n        const element = getCurrentElement() as any as CustomElement & ICustomElement;\n\n        if (connectedCallback) {\n            connectedCallback.call(element);\n        }\n\n        if (disconnectedCallback) {\n            element.addReleaseCallback(() => disconnectedCallback.call(element));\n        }\n\n        if (element.renderRoot === element.shadowRoot) {\n            return <>\n                {shadowStyles && (typeof shadowStyles === \"string\" ? [shadowStyles] : shadowStyles).map(style => <style>{style}</style>)}\n                {element[\"template\"]({props, children: []})}\n            </>\n        } else {\n            return element[\"template\"]({props, children: children.slottedChildren ?? []});\n        }\n    });\n\n    if (renderRoot?.get) {\n        Object.defineProperty(finalConstructor.prototype, \"renderRoot\", {\n            get() {\n                const root = renderRoot?.get?.call(this);\n                if (root) {\n                    return root;\n                } else {\n                    const shadow = (this as HTMLElement).shadowRoot;\n                    if (!shadow) {\n                        return (this as HTMLElement).attachShadow({mode: \"open\"});\n                    }\n                }\n            }\n        })\n    }\n}\n"],"names":["registerElement","tagName","elementConstructor","customElements","get","extendedConstructor","propsDefinitions","slottedChildren","value","undefined","attribute","notify","reflect","parse","propName","propValue","Object","entries","reactive","propConfig","assign","connectedCallback","prototype","disconnectedCallback","renderRoot","parentClass","HTMLElement","getOwnPropertyDescriptor","getPrototypeOf","finalConstructor","compose","register","BaseElement","withSolid","rawProps","shadowStyles","__shadowStyles","children","props","splitProps","element","getCurrentElement","call","addReleaseCallback","shadowRoot","_$memo","map","style","_el$","_tmpl$","_$insert","defineProperty","root","attachShadow","mode"],"mappings":";;;;;AAMO,SAASA,EAAmDC,GAAiBC,GAAiD;AAEjI,MAAIC,eAAeC,IAAIH,CAAO;AAC1B;AAGJ,QAAMI,IAAoGH,GAEpGI,IAMG;AAAA,IAACC,iBAAiB;AAAA,MAACC,OAAOC;AAAAA,MAAWC,WAAW;AAAA,MAAoBC,QAAQ;AAAA,MAAOC,SAAS;AAAA,MAAOC,OAAO;AAAA,IAAK;AAAA;AAExH,aAAW,CAACC,GAAUC,CAAS,KAAKC,OAAOC,QAAQZ,EAAoBa,YAAY,CAAA,CAAE,GAAG;AACpF,UAAMC,IAAa;AAAA,MAACX,OAAOC;AAAAA,MAAWE,QAAQ;AAAA,MAAOE,OAAO;AAAA,MAAOD,SAAS;AAAA,MAAOF,WAAWD;AAAAA;AAE9F,IAAI,OAAOM,KAAc,YACrBC,OAAOI,OAAOD,GAAYJ,CAAS,GAGvCT,EAAiBQ,CAAQ,IAAIK;AAAAA,EACjC;AAEA,QAAME,IAAoBnB,EAAmBoB,UAAUD,mBACjDE,IAAuBrB,EAAmBoB,UAAUC;AAE1D,MAAIC,GAEAC,IAAcvB;AAClB,SAAOuB,MAAgBC,gBACnBF,IAAaR,OAAOW,yBAAyBF,EAAYH,WAAW,YAAY,GAC5EE,CAAAA;AAGJC,IAAAA,IAAcT,OAAOY,eAAeH,CAAW;AAGnD,QAAMI,IAAmBC,EAAQC,EAAS9B,GAASK,GAAkB;AAAA,IAAC0B,aAAa9B;AAAAA,EAAkB,CAAC,GAAG+B,CAAS,EAAGC,CAAAA,MAAa;AAE9H,UAAMC,IAAe9B,EAAoB+B,gBACnC,CAACC,GAAUC,CAAK,IAAIC,EAAWL,GAAU,CAAC,iBAAiB,CAAC,GAE5DM,IAAUC;AAUhB,WARIpB,KACAA,EAAkBqB,KAAKF,CAAO,GAG9BjB,KACAiB,EAAQG,mBAAmB,MAAMpB,EAAqBmB,KAAKF,CAAO,CAAC,GAGnEA,EAAQhB,eAAegB,EAAQI,aAC/B,CAAAC,EAAA,MACKV,MAAiB,OAAOA,KAAiB,WAAW,CAACA,CAAY,IAAIA,GAAcW,IAAIC,CAAAA,OAAK,MAAA;AAAA,YAAAC,IAAAC;AAAAC,aAAAA,EAAAF,GAAYD,CAAK,GAAAC;AAAA,IAAA,GAAA,CAAS,CAAC,GACvHR,EAAAA,MAAAA,EAAQ,SAAY;AAAA,MAACF,OAAAA;AAAAA,MAAOD,UAAU,CAAA;AAAA,IAAG,CAAA,CAAC,CAAA,IAGxCG,EAAQ,SAAY;AAAA,MAACF,OAAAA;AAAAA,MAAOD,UAAUA,EAAS9B,mBAAmB,CAAA;AAAA,IAAE,CAAC;AAAA,EAEpF,CAAC;AAED,EAAIiB,KAAAA,QAAAA,EAAYpB,OACZY,OAAOmC,eAAetB,EAAiBP,WAAW,cAAc;AAAA,IAC5DlB,MAAM;;AACF,YAAMgD,KAAO5B,IAAAA,KAAAA,gBAAAA,EAAYpB,QAAZoB,gBAAAA,EAAiBkB,KAAK;AACnC,UAAIU;AACA,eAAOA;AAGP,UAAI,CADY,KAAqBR;AAEjC,eAAQ,KAAqBS,aAAa;AAAA,UAACC,MAAM;AAAA,QAAM,CAAC;AAAA,IAGpE;AAAA,EACJ,CAAC;AAET;"}