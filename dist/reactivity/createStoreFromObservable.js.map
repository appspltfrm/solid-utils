{"version":3,"file":"createStoreFromObservable.js","sources":["../../src/lib/reactivity/createStoreFromObservable.ts"],"sourcesContent":["import {Observable, Subscription} from \"rxjs\";\nimport {createMemo, EffectFunction, getOwner, onCleanup} from \"solid-js\";\nimport {createStore, SetStoreFunction, Store} from \"solid-js/store\";\n\ntype StoreValue = {};\n\nexport type StoreFromObservable<T extends StoreValue> = [get: Store<T>, set: SetStoreFunction<T>, subscription: Subscription];\n\ninterface InitialValueOption<T> {\n    value: T;\n}\n\nexport interface Options {\n    onError?: (error: any) => void | any;\n    autoUnsubscribe?: boolean;\n}\n\ninterface CreateStoreFromObservableOption<T extends StoreValue> extends Options, Partial<InitialValueOption<T>> {\n}\n\nexport function createStoreFromObservable<T extends StoreValue, Init extends Partial<T>>(observable: Observable<T>, options: InitialValueOption<Init> & Options): StoreFromObservable<T & Init>;\n\nexport function createStoreFromObservable<T extends StoreValue, Init extends Partial<T>>(observable: Observable<T>, options?: CreateStoreFromObservableOption<Init>): StoreFromObservable<T & Init>;\n\nexport function createStoreFromObservable<Next extends Prev, Prev extends StoreValue = Next, Init extends StoreValue = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options: InitialValueOption<Init> & Options): StoreFromObservable<Next>;\n\nexport function createStoreFromObservable<Next extends Prev, Prev extends StoreValue = Next, Init extends StoreValue = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options?: CreateStoreFromObservableOption<Init>): StoreFromObservable<Next>;\n\nexport function createStoreFromObservable<T extends StoreValue>(observableOrMemo: Observable<T> | EffectFunction<undefined | Observable<T>, Observable<T>>, options?: CreateStoreFromObservableOption<T>): StoreFromObservable<T> {\n\n    if (typeof observableOrMemo === \"function\") {\n\n        type Memo = [Observable<T>, Store<T>, SetStoreFunction<T>, Subscription];\n        const data = createMemo<Memo>((prev) => {\n\n            const prevObservable = prev?.[0];\n            const newObservable = observableOrMemo(prevObservable);\n\n            if (prevObservable === newObservable) {\n                return prev as Memo;\n            }\n\n            if (prev) {\n                prev![3].unsubscribe();\n            }\n\n            return [newObservable, ...createStoreFromObservable(newObservable, options)];\n        });\n\n        // @ts-ignore\n        return [data()[1], (v: T) => data()[2](v), () => data()[3].unsubscribe()];\n    }\n\n    const [store, setStore] = createStore<T>((options?.value || {}) as any);\n\n    const subscription = observableOrMemo.subscribe({\n        next: (v: T) => setStore(() => v),\n        error: (e: any) => options?.onError?.(e)\n    });\n\n    if (getOwner() && options?.autoUnsubscribe !== false) {\n        onCleanup(() => subscription.unsubscribe());\n    }\n\n    return [store, setStore, subscription];\n}\n"],"names":["createStoreFromObservable","observableOrMemo","options","data","createMemo","prev","prevObservable","newObservable","v","store","setStore","createStore","subscription","e","_a","getOwner","onCleanup"],"mappings":";;AA4BgB,SAAAA,EAAgDC,GAA4FC,GAAsE;AAE1N,MAAA,OAAOD,KAAqB,YAAY;AAGlC,UAAAE,IAAOC,EAAiB,CAACC,MAAS;AAE9B,YAAAC,IAAiBD,KAAA,gBAAAA,EAAO,IACxBE,IAAgBN,EAAiBK,CAAc;AAErD,aAAIA,MAAmBC,IACZF,KAGPA,KACMA,EAAA,CAAC,EAAE,eAGN,CAACE,GAAe,GAAGP,EAA0BO,GAAeL,CAAO,CAAC;AAAA,IAAA,CAC9E;AAGD,WAAO,CAACC,EAAK,EAAE,CAAC,GAAG,CAACK,MAASL,IAAO,CAAC,EAAEK,CAAC,GAAG,MAAML,EAAA,EAAO,CAAC,EAAE,aAAa;AAAA,EAC5E;AAEM,QAAA,CAACM,GAAOC,CAAQ,IAAIC,GAAgBT,KAAA,gBAAAA,EAAS,UAAS,CAAA,CAAU,GAEhEU,IAAeX,EAAiB,UAAU;AAAA,IAC5C,MAAM,CAACO,MAASE,EAAS,MAAMF,CAAC;AAAA,IAChC,OAAO,CAACK,MAAW;;AAAA,cAAAC,IAAAZ,KAAA,gBAAAA,EAAS,YAAT,gBAAAY,EAAA,KAAAZ,GAAmBW;AAAA;AAAA,EAAC,CAC1C;AAED,SAAIE,EAAS,MAAKb,KAAA,gBAAAA,EAAS,qBAAoB,MACjCc,EAAA,MAAMJ,EAAa,YAAA,CAAa,GAGvC,CAACH,GAAOC,GAAUE,CAAY;AACzC;"}