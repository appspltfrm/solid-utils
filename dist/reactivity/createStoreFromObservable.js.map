{"version":3,"file":"createStoreFromObservable.js","sources":["../../src/lib/reactivity/createStoreFromObservable.ts"],"sourcesContent":["import {Observable, Subscription} from \"rxjs\";\nimport {Accessor, createEffect, createSignal, EffectFunction, getOwner, onCleanup, untrack} from \"solid-js\";\nimport {createStore, SetStoreFunction, Store} from \"solid-js/store\";\n\ntype StoreValue = {};\n\nexport type StoreFromObservable<T extends StoreValue> = [get: Store<T>, set: SetStoreFunction<T>, subscription: Accessor<Subscription>];\n\ninterface InitialValueOption<T> {\n    value: T;\n}\n\nexport interface Options {\n    onError?: (error: any) => void | any;\n    autoUnsubscribe?: boolean;\n}\n\ninterface CreateStoreFromObservableOption<T extends StoreValue> extends Options, Partial<InitialValueOption<T>> {\n}\n\nexport function createStoreFromObservable<T extends StoreValue, Init extends Partial<T>>(observable: Observable<T>, options: InitialValueOption<Init> & Options): StoreFromObservable<T & Init>;\n\nexport function createStoreFromObservable<T extends StoreValue, Init extends Partial<T>>(observable: Observable<T>, options?: CreateStoreFromObservableOption<Init>): StoreFromObservable<T & Init>;\n\nexport function createStoreFromObservable<Next extends Prev, Prev extends StoreValue = Next, Init extends StoreValue = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options: InitialValueOption<Init> & Options): StoreFromObservable<Next>;\n\nexport function createStoreFromObservable<Next extends Prev, Prev extends StoreValue = Next, Init extends StoreValue = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options?: CreateStoreFromObservableOption<Init>): StoreFromObservable<Next>;\n\nexport function createStoreFromObservable<T extends StoreValue>(observableOrMemo: Observable<T> | EffectFunction<undefined | Observable<T>, Observable<T>>, options?: CreateStoreFromObservableOption<T>): StoreFromObservable<T> {\n\n    const [store, setStore] = createStore<T>((options?.value || {}) as any);\n    const [subscription, setSubscription] = createSignal<Subscription>(undefined!);\n\n    const subscribe = (o: Observable<T>) => setSubscription(p => {\n        p?.unsubscribe();\n        return o.subscribe({\n            next: (v: T) => setStore(() => v),\n            error: (e: any) => options?.onError?.(e)\n        })\n    })\n\n    if (typeof observableOrMemo === \"function\") {\n        createEffect<Observable<T> | undefined>(prev => {\n            const obs = observableOrMemo(prev);\n            if (obs === prev) {\n                return prev;\n            }\n            subscribe(obs)\n            return obs\n        })\n    } else {\n        subscribe(observableOrMemo)\n    }\n\n    if (getOwner() && options?.autoUnsubscribe !== false) {\n        onCleanup(() => subscription()?.unsubscribe());\n    }\n\n    return [store, setStore, subscription];\n}\n"],"names":["createStoreFromObservable","observableOrMemo","options","store","setStore","createStore","subscription","setSubscription","createSignal","subscribe","o","p","v","e","_a","createEffect","prev","obs","getOwner","onCleanup"],"mappings":";;AA4BgB,SAAAA,EAAgDC,GAA4FC,GAAsE;AAExN,QAAA,CAACC,GAAOC,CAAQ,IAAIC,GAAgBH,KAAA,gBAAAA,EAAS,UAAS,EAAU,GAChE,CAACI,GAAcC,CAAe,IAAIC,EAA2B,MAAU,GAEvEC,IAAY,CAACC,MAAqBH,EAAgB,CAAKI,OACzDA,KAAA,QAAAA,EAAG,eACID,EAAE,UAAU;AAAA,IACf,MAAM,CAACE,MAASR,EAAS,MAAMQ,CAAC;AAAA,IAChC,OAAO,CAACC;;AAAW,cAAAC,IAAAZ,KAAA,gBAAAA,EAAS,YAAT,gBAAAY,EAAA,KAAAZ,GAAmBW;AAAA;AAAA,EAAC,CAC1C,EACJ;AAEG,SAAA,OAAOZ,KAAqB,aAC5Bc,EAAwC,CAAQC,MAAA;AACtC,UAAAC,IAAMhB,EAAiBe,CAAI;AACjC,WAAIC,MAAQD,IACDA,KAEXP,EAAUQ,CAAG,GACNA;AAAA,EAAA,CACV,IAEDR,EAAUR,CAAgB,GAG1BiB,EAAS,MAAKhB,KAAA,gBAAAA,EAAS,qBAAoB,MAC3CiB,EAAU,MAAM;;AAAA,YAAAL,IAAAR,QAAA,gBAAAQ,EAAgB;AAAA,GAAa,GAG1C,CAACX,GAAOC,GAAUE,CAAY;AACzC;"}