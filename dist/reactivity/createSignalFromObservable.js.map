{"version":3,"file":"createSignalFromObservable.js","sources":["../../src/lib/reactivity/createSignalFromObservable.ts"],"sourcesContent":["import {Observable, Subscription} from \"rxjs\";\nimport {Accessor, createMemo, createSignal, EffectFunction, getOwner, onCleanup, Setter, Signal} from \"solid-js\";\n\nexport type SignalFromObservable<T> = [...Signal<T>, Subscription];\n\ninterface InitialValueOption<T> {\n    value: T;\n}\n\nexport interface Options {\n    onError?: (error: any) => void | any;\n    autoUnsubscribe?: boolean;\n}\n\ninterface CreateSignalFromObservableOption<T> extends Options, Partial<InitialValueOption<T>> {\n}\n\nexport function createSignalFromObservable<T>(observable: Observable<T>, options: InitialValueOption<T> & Options): SignalFromObservable<T>;\n\nexport function createSignalFromObservable<T>(observable: Observable<T>, options?: CreateSignalFromObservableOption<T | undefined>): SignalFromObservable<T | undefined>;\n\nexport function createSignalFromObservable<Next extends Prev, Init = Next, Prev = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options: InitialValueOption<Init> & Options): SignalFromObservable<Next>;\n\nexport function createSignalFromObservable<Next extends Prev, Init = Next, Prev = Next>(memo: EffectFunction<undefined | Observable<Prev>, Observable<Next>>, options?: CreateSignalFromObservableOption<Init | undefined>): SignalFromObservable<Next | undefined>;\n\nexport function createSignalFromObservable<T>(observableOrMemo: Observable<T> | EffectFunction<undefined | Observable<T>, Observable<T>>, options?: CreateSignalFromObservableOption<T | undefined>): SignalFromObservable<T | undefined> {\n\n    if (typeof observableOrMemo === \"function\") {\n\n        type Memo = [Observable<T>, Accessor<T | undefined>, Setter<T | undefined>, Subscription];\n        const data = createMemo<Memo>((prev) => {\n\n            const prevObservable = prev?.[0];\n            const newObservable = observableOrMemo(prevObservable);\n\n            if (prevObservable === newObservable) {\n                return prev as Memo;\n            }\n\n            if (prev) {\n                prev![3].unsubscribe();\n            }\n\n            return [newObservable, ...createSignalFromObservable(newObservable, options)];\n        });\n\n        // @ts-ignore\n        return [() => data()[1](), (v: T) => data()[2](v), () => data()[3].unsubscribe()];\n    }\n\n    const [value, setValue] = createSignal<T | undefined>(options?.value);\n\n    const subscription = observableOrMemo.subscribe({\n        next: (v: T) => setValue(() => v),\n        error: (e: any) => options?.onError?.(e)\n    });\n\n    if (getOwner() && options?.autoUnsubscribe !== false) {\n        onCleanup(() => subscription.unsubscribe());\n    }\n\n    return [value, setValue, subscription];\n}\n"],"names":["createSignalFromObservable","observableOrMemo","options","data","createMemo","prev","prevObservable","newObservable","v","value","setValue","createSignal","subscription","e","_a","getOwner","onCleanup"],"mappings":";AAyBgB,SAAAA,EAA8BC,GAA4FC,GAAgG;AAElO,MAAA,OAAOD,KAAqB,YAAY;AAGlC,UAAAE,IAAOC,EAAiB,CAACC,MAAS;AAE9B,YAAAC,IAAiBD,KAAA,gBAAAA,EAAO,IACxBE,IAAgBN,EAAiBK,CAAc;AAErD,aAAIA,MAAmBC,IACZF,KAGPA,KACMA,EAAA,CAAC,EAAE,YAAY,GAGlB,CAACE,GAAe,GAAGP,EAA2BO,GAAeL,CAAO,CAAC;AAAA,IAAA,CAC/E;AAGM,WAAA,CAAC,MAAMC,EAAK,EAAE,CAAC,EAAE,GAAG,CAACK,MAASL,EAAA,EAAO,CAAC,EAAEK,CAAC,GAAG,MAAML,EAAO,EAAA,CAAC,EAAE,aAAa;AAAA,EAAA;AAGpF,QAAM,CAACM,GAAOC,CAAQ,IAAIC,EAA4BT,KAAA,gBAAAA,EAAS,KAAK,GAE9DU,IAAeX,EAAiB,UAAU;AAAA,IAC5C,MAAM,CAACO,MAASE,EAAS,MAAMF,CAAC;AAAA,IAChC,OAAO,CAACK;;AAAW,cAAAC,IAAAZ,KAAA,gBAAAA,EAAS,YAAT,gBAAAY,EAAA,KAAAZ,GAAmBW;AAAA;AAAA,EAAC,CAC1C;AAED,SAAIE,EAAS,MAAKb,KAAA,gBAAAA,EAAS,qBAAoB,MACjCc,EAAA,MAAMJ,EAAa,aAAa,GAGvC,CAACH,GAAOC,GAAUE,CAAY;AACzC;"}